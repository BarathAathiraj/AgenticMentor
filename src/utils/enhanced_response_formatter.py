#!/usr/bin/env python3
"""
Enhanced Response Formatter for Agentic Mentor
Creates structured, visually appealing responses with flowcharts and diagrams
"""

import re
import json
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum
from src.models import SearchResult


class ResponseType(Enum):
    PROJECT_OVERVIEW = "project_overview"
    TECHNICAL_DETAILS = "technical_details"
    PROCESS_FLOW = "process_flow"
    COMPARISON = "comparison"
    TUTORIAL = "tutorial"
    ANALYSIS = "analysis"


@dataclass
class StructuredResponse:
    title: str
    sections: List[Dict[str, Any]]
    flowchart: Optional[str] = None
    summary: str = ""
    next_steps: List[str] = None


class EnhancedResponseFormatter:
    """Enhanced formatter for creating structured, visual responses"""
    
    @staticmethod
    def format_project_response(project_name: str, content: str, metadata: Dict[str, Any]) -> str:
        """Format a project response with enhanced structure"""
        
        # Extract key information
        features = EnhancedResponseFormatter._extract_features(content)
        tech_stack = EnhancedResponseFormatter._extract_tech_stack(content)
        architecture = EnhancedResponseFormatter._extract_architecture(content)
        
        # Create flowchart for project structure
        flowchart = EnhancedResponseFormatter._generate_project_flowchart(project_name, features, tech_stack)
        
        response = f"""## ğŸš€ **{project_name}** - Project Analysis

### ğŸ“Š **Overview**
**Purpose:** {EnhancedResponseFormatter._extract_description(content)}
**Status:** {metadata.get('status', 'Active Development')}
**Repository:** {metadata.get('source_url', 'N/A')}

### ğŸ¯ **Key Features**
"""
        
        for i, feature in enumerate(features[:3], 1):  # Limit to 3 features
            response += f"{i}. **{feature['name']}:** {feature['description']}\n"
        
        response += f"""
### ğŸ”§ **Tech Stack**
"""
        
        if tech_stack:
            for category, techs in list(tech_stack.items())[:3]:  # Limit to 3 categories
                response += f"- **{category}:** {', '.join(techs[:3])}\n"  # Limit to 3 techs per category
        
        response += f"""
### ğŸ“ˆ **Architecture**
```mermaid
{flowchart}
```

### ğŸ’¡ **Summary**
- {EnhancedResponseFormatter._extract_summary_points(content)[0]}
- {EnhancedResponseFormatter._extract_summary_points(content)[1]}
- {EnhancedResponseFormatter._extract_summary_points(content)[2]}

### ğŸ¯ **Next Steps**
{EnhancedResponseFormatter._generate_crisp_next_steps()}

---
*Generated by Agentic Mentor*"""
        
        return response
    
    @staticmethod
    def format_technical_response(query: str, content: str, sources: List[Dict[str, Any]]) -> str:
        """Format a technical response with detailed analysis"""
        
        # Analyze the query type
        query_type = EnhancedResponseFormatter._classify_query(query)
        
        response = f"""## ğŸ” **{query}** - Technical Analysis

### ğŸ“š **Sources**
"""
        
        for i, source in enumerate(sources[:2], 1):  # Limit to 2 sources
            response += f"{i}. **{source.get('type', 'Unknown')}** - {source.get('url', 'N/A')}\n"
        
        response += f"""
### ğŸ’¡ **Analysis**
{EnhancedResponseFormatter._truncate_content(content, 300)}

### ğŸ”§ **Implementation**
"""
        
        if query_type == "implementation":
            response += EnhancedResponseFormatter._generate_quick_implementation_guide(content)
        elif query_type == "architecture":
            response += EnhancedResponseFormatter._generate_simple_architecture_diagram(query)
        elif query_type == "comparison":
            response += EnhancedResponseFormatter._generate_quick_comparison_table(content)
        
        response += f"""
### ğŸ“Š **Key Points**
- **Complexity:** {EnhancedResponseFormatter._assess_complexity(content)}
- **Time:** {EnhancedResponseFormatter._estimate_implementation_time(content)}
- **Best Practice:** {EnhancedResponseFormatter._extract_best_practices(content)}

### ğŸ¯ **Recommendations**
{EnhancedResponseFormatter._generate_crisp_recommendations(content, query_type)}

---
*Analysis by Agentic Mentor*"""
        
        return response
    
    @staticmethod
    def format_process_flow(process_name: str, steps: List[str], decision_points: List[Dict[str, Any]] = None) -> str:
        """Format a process flow with flowchart"""
        
        flowchart = EnhancedResponseFormatter._generate_process_flowchart(process_name, steps, decision_points)
        
        response = f"""## ğŸ”„ **{process_name}** - Process Flow

### ğŸ“‹ **Overview**
{len(steps)} steps with {len(decision_points) if decision_points else 0} decision points.

### ğŸ”„ **Flow**
```mermaid
{flowchart}
```

### ğŸ“ **Steps**
"""
        
        for i, step in enumerate(steps[:5], 1):  # Limit to 5 steps
            response += f"{i}. {step}\n"
        
        if len(steps) > 5:
            response += f"... and {len(steps) - 5} more steps\n"
        
        response += f"""
### âš¡ **Optimization**
- **Automation:** {EnhancedResponseFormatter._assess_automation_potential(steps)}
- **Bottlenecks:** {EnhancedResponseFormatter._identify_bottlenecks(steps)}

### ğŸ¯ **Next Steps**
{EnhancedResponseFormatter._generate_process_next_steps()}

---
*Process analysis by Agentic Mentor*"""
        
        return response
    
    @staticmethod
    def _extract_features(content: str) -> List[Dict[str, str]]:
        """Extract features from content"""
        features = []
        
        # Look for feature patterns
        feature_patterns = [
            r'features?[:\s]+([^.]*)',
            r'functionality[:\s]+([^.]*)',
            r'capabilities?[:\s]+([^.]*)',
            r'provides?[:\s]+([^.]*)',
            r'includes?[:\s]+([^.]*)'
        ]
        
        for pattern in feature_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if match.strip():
                    features.append({
                        'name': 'Feature',
                        'description': match.strip()
                    })
        
        # If no features found, create generic ones
        if not features:
            features = [
                {'name': 'Documentation', 'description': 'Comprehensive docs and guides'},
                {'name': 'Modern Architecture', 'description': 'Contemporary design patterns'},
                {'name': 'Scalable Design', 'description': 'Built for growth'}
            ]
        
        return features[:3]  # Limit to 3 features
    
    @staticmethod
    def _extract_tech_stack(content: str) -> Dict[str, List[str]]:
        """Extract technology stack from content"""
        tech_stack = {
            'Frontend': [],
            'Backend': [],
            'Database': [],
            'DevOps': [],
            'Testing': []
        }
        
        # Common technology patterns
        tech_patterns = {
            'Frontend': [r'React', r'Vue', r'Angular', r'HTML', r'CSS', r'JavaScript', r'TypeScript'],
            'Backend': [r'Python', r'Node\.js', r'Java', r'C#', r'PHP', r'FastAPI', r'Django', r'Flask'],
            'Database': [r'PostgreSQL', r'MySQL', r'MongoDB', r'Redis', r'SQLite'],
            'DevOps': [r'Docker', r'Kubernetes', r'AWS', r'Azure', r'GitHub Actions'],
            'Testing': [r'Jest', r'PyTest', r'JUnit', r'Selenium']
        }
        
        for category, patterns in tech_patterns.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    tech_stack[category].append(pattern)
        
        # Remove empty categories and limit to top 3
        return {k: v[:3] for k, v in tech_stack.items() if v}
    
    @staticmethod
    def _extract_architecture(content: str) -> str:
        """Extract architecture pattern from content"""
        architecture_patterns = [
            r'MVC',
            r'MVVM',
            r'Microservices',
            r'Monolithic',
            r'Event-Driven',
            r'Layered Architecture'
        ]
        
        for pattern in architecture_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return pattern
        
        return "Modern Web Architecture"
    
    @staticmethod
    def _generate_project_flowchart(project_name: str, features: List[Dict[str, str]], tech_stack: Dict[str, List[str]]) -> str:
        """Generate Mermaid flowchart for project structure"""
        
        flowchart = f"""graph TD
    A[{project_name}] --> B[Frontend]
    A --> C[Backend]
    A --> D[Database]
    
    B --> B1[UI Components]
    C --> C1[API Layer]
    C --> C2[Business Logic]
    D --> D1[Data Storage]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0"""
        
        return flowchart
    
    @staticmethod
    def _generate_process_flowchart(process_name: str, steps: List[str], decision_points: List[Dict[str, Any]] = None) -> str:
        """Generate Mermaid flowchart for process flow"""
        
        flowchart = f"""graph TD
    A[Start]"""
        
        for i, step in enumerate(steps[:5], 1):  # Limit to 5 steps
            flowchart += f"\n    A{i-1 if i > 1 else 'A'} --> A{i}[{step[:15]}...]"
        
        if len(steps) > 5:
            flowchart += f"\n    A5 --> A6[...]"
        
        flowchart += f"\n    A{min(len(steps), 5)} --> Z[End]"
        flowchart += "\n\n    style A fill:#e1f5fe"
        flowchart += "\n    style Z fill:#c8e6c9"
        
        return flowchart
    
    @staticmethod
    def _classify_query(query: str) -> str:
        """Classify the type of query"""
        query_lower = query.lower()
        
        if any(word in query_lower for word in ['how', 'implement', 'create', 'build']):
            return "implementation"
        elif any(word in query_lower for word in ['architecture', 'design', 'structure']):
            return "architecture"
        elif any(word in query_lower for word in ['compare', 'difference', 'vs']):
            return "comparison"
        elif any(word in query_lower for word in ['process', 'flow', 'workflow']):
            return "process"
        else:
            return "analysis"
    
    @staticmethod
    def _assess_complexity(content: str) -> str:
        """Assess the complexity of the content"""
        word_count = len(content.split())
        tech_terms = len(re.findall(r'\b(API|Database|Framework|Library|Service|Component)\b', content, re.IGNORECASE))
        
        if word_count > 500 and tech_terms > 10:
            return "High"
        elif word_count > 200 and tech_terms > 5:
            return "Medium"
        else:
            return "Low"
    
    @staticmethod
    def _estimate_implementation_time(content: str) -> str:
        """Estimate implementation time based on content"""
        complexity = EnhancedResponseFormatter._assess_complexity(content)
        
        if "High" in complexity:
            return "2-4 weeks"
        elif "Medium" in complexity:
            return "1-2 weeks"
        else:
            return "3-5 days"
    
    @staticmethod
    def _extract_best_practices(content: str) -> str:
        """Extract best practices from content"""
        practices = [
            "Follow SOLID principles",
            "Implement proper error handling",
            "Use version control effectively",
            "Write comprehensive tests",
            "Document your code"
        ]
        
        return practices[0]  # Return only the first practice
    
    @staticmethod
    def _generate_crisp_recommendations(content: str, query_type: str) -> str:
        """Generate crisp recommendations based on content and query type"""
        recommendations = []
        
        if query_type == "implementation":
            recommendations = [
                "Start with a proof of concept",
                "Break down into smaller tasks",
                "Set up proper dev environment",
                "Create comprehensive tests"
            ]
        elif query_type == "architecture":
            recommendations = [
                "Consider scalability requirements",
                "Plan for future maintenance",
                "Document architectural decisions",
                "Implement monitoring"
            ]
        else:
            recommendations = [
                "Review existing documentation",
                "Analyze current implementation",
                "Identify improvements",
                "Plan incremental updates"
            ]
        
        # Return only first 2 recommendations
        return "\n".join([f"- {rec}" for rec in recommendations[:2]])
    
    @staticmethod
    def _extract_description(content: str) -> str:
        """Extract project description from content"""
        # Look for description patterns
        desc_patterns = [
            r'description[:\s]+([^.]*)',
            r'about[:\s]+([^.]*)',
            r'overview[:\s]+([^.]*)'
        ]
        
        for pattern in desc_patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                return match.group(1).strip()
        
        # Fallback to first sentence
        sentences = content.split('.')
        return sentences[0] if sentences else "A comprehensive project with modern development practices."
    
    @staticmethod
    def _extract_summary_points(content: str) -> List[str]:
        """Extract summary points from content"""
        points = [
            "Comprehensive documentation and clear instructions",
            "Modern architecture with best practices",
            "Scalable design for future growth"
        ]
        
        return points
    
    @staticmethod
    def _generate_crisp_next_steps() -> str:
        """Generate crisp next steps"""
        steps = [
            "Review project documentation",
            "Set up development environment",
            "Explore codebase structure",
            "Run application locally",
            "Contribute to project"
        ]
        
        return "\n".join([f"{i}. {step}" for i, step in enumerate(steps[:3], 1)])
    
    @staticmethod
    def _truncate_content(content: str, max_length: int = 300) -> str:
        """Truncate content to specified length"""
        if len(content) <= max_length:
            return content
        
        # Truncate at word boundary
        truncated = content[:max_length]
        last_space = truncated.rfind(' ')
        if last_space > max_length * 0.8:  # If we can find a space in the last 20%
            truncated = truncated[:last_space]
        
        return truncated + "..."
    
    @staticmethod
    def _generate_quick_implementation_guide(content: str) -> str:
        """Generate a quick implementation guide"""
        return """1. **Setup Environment** - Install dependencies
2. **Create Structure** - Initialize project
3. **Implement Core** - Build main features
4. **Add Tests** - Ensure quality
5. **Deploy** - Go live"""
    
    @staticmethod
    def _generate_simple_architecture_diagram(query: str) -> str:
        """Generate a simple architecture diagram"""
        return """```mermaid
graph TD
    A[User Interface] --> B[API Gateway]
    B --> C[Business Logic]
    C --> D[Database]
    
    style A fill:#e3f2fd
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0
```"""
    
    @staticmethod
    def _generate_quick_comparison_table(content: str) -> str:
        """Generate a quick comparison table"""
        return """| Aspect | Option A | Option B |
|--------|----------|----------|
| Performance | High | Medium |
| Scalability | Good | Excellent |
| Complexity | Low | Medium |"""
    
    @staticmethod
    def _assess_automation_potential(steps: List[str]) -> str:
        """Assess automation potential of process steps"""
        automation_keywords = ['manual', 'automated', 'script', 'tool', 'api']
        automation_count = sum(1 for step in steps if any(keyword in step.lower() for keyword in automation_keywords))
        
        if automation_count > len(steps) * 0.7:
            return "High - Most steps can be automated"
        elif automation_count > len(steps) * 0.4:
            return "Medium - Some steps can be automated"
        else:
            return "Low - Primarily manual process"
    
    @staticmethod
    def _identify_bottlenecks(steps: List[str]) -> str:
        """Identify potential bottlenecks in process"""
        bottleneck_keywords = ['review', 'approval', 'manual', 'wait', 'queue']
        bottleneck_count = sum(1 for step in steps if any(keyword in step.lower() for keyword in bottleneck_keywords))
        
        if bottleneck_count > 0:
            return f"{bottleneck_count} potential bottleneck(s)"
        else:
            return "No obvious bottlenecks"
    
    @staticmethod
    def _generate_process_next_steps() -> str:
        """Generate next steps for process analysis"""
        steps = [
            "Automate repetitive tasks",
            "Implement parallel processing",
            "Add monitoring and metrics",
            "Create clear documentation",
            "Establish feedback loops"
        ]
        
        return "\n".join([f"{i}. {step}" for i, step in enumerate(steps[:3], 1)])
    
    @staticmethod
    def enhance_response_structure(response_text: str, query_text: str, search_results: List[SearchResult]) -> str:
        """Enhance the structure of a response with better formatting and flowcharts"""
        
        # Clean up any duplicate sections first
        response_text = EnhancedResponseFormatter._clean_duplicate_sections(response_text)
        
        # Ensure the response starts with a main heading
        if not response_text.strip().startswith('##'):
            response_text = f"## ğŸš€ **Analysis Results**\n\n{response_text}"
        
        # Add flowchart if the query is about processes or workflows
        if any(word in query_text.lower() for word in ['process', 'flow', 'workflow', 'steps', 'how']):
            flowchart = EnhancedResponseFormatter._generate_simple_process_flowchart(query_text)
            response_text += f"\n\n### ğŸ“ˆ **Process Flow**\n```mermaid\n{flowchart}\n```"
        
        # Add technical architecture diagram if the query is about architecture
        if any(word in query_text.lower() for word in ['architecture', 'design', 'structure', 'system']):
            arch_diagram = EnhancedResponseFormatter._generate_simple_architecture_diagram(query_text)
            response_text += f"\n\n### ğŸ—ï¸ **System Architecture**\n```mermaid\n{arch_diagram}\n```"
        
        # Add comparison table if the query is about comparison
        if any(word in query_text.lower() for word in ['compare', 'difference', 'vs', 'versus']):
            comparison_table = EnhancedResponseFormatter._generate_comparison_table(query_text, search_results)
            response_text += f"\n\n### ğŸ“Š **Comparison Analysis**\n{comparison_table}"
        
        # Add summary section if not present (only one summary section)
        if "### ğŸ’¡ **Summary**" not in response_text and "### ğŸ“‹ **Summary**" not in response_text:
            summary = EnhancedResponseFormatter._generate_summary(response_text)
            response_text += f"\n\n### ğŸ’¡ **Summary**\n{summary}"
        
        # Add next steps if not present (only one next steps section)
        if "### ğŸ“‹ **Next Steps**" not in response_text and "### ğŸ¯ **Next Steps**" not in response_text:
            next_steps = EnhancedResponseFormatter._generate_next_steps(query_text, search_results)
            response_text += f"\n\n### ğŸ¯ **Next Steps**\n{next_steps}"
        
        # Add follow-up recommendations (only if not already present)
        if "### ğŸ’¬ **Follow-up Options**" not in response_text:
            follow_ups = EnhancedResponseFormatter._generate_follow_up_recommendations(query_text)
            response_text += f"\n\n### ğŸ’¬ **Follow-up Options**\n{follow_ups}"
        
        # Add variety to make responses more dynamic
        response_text = EnhancedResponseFormatter._add_response_variety(response_text)
        
        return response_text
    
    @staticmethod
    def _clean_duplicate_sections(response_text: str) -> str:
        """Clean up duplicate sections in the response"""
        lines = response_text.split('\n')
        cleaned_lines = []
        seen_sections = set()
        
        for line in lines:
            # Check if this is a section header
            if line.strip().startswith('###'):
                section_name = line.strip()
                if section_name in seen_sections:
                    # Skip duplicate sections
                    continue
                else:
                    seen_sections.add(section_name)
                    cleaned_lines.append(line)
            else:
                cleaned_lines.append(line)
        
        return '\n'.join(cleaned_lines)
    
    @staticmethod
    def _generate_simple_process_flowchart(query_text: str) -> str:
        """Generate a simple process flowchart based on query"""
        flowchart = """graph TD
    A[Start] --> B[Initial Analysis]
    B --> C[Data Processing]
    C --> D[Decision Point]
    D -->|Success| E[Implementation]
    D -->|Review| F[Refinement]
    F --> C
    E --> G[Validation]
    G --> H[Deployment]
    H --> I[Monitoring]
    I --> J[End]
    
    style A fill:#e1f5fe
    style J fill:#c8e6c9
    style D fill:#fff3e0"""
        
        return flowchart
    
    @staticmethod
    def _generate_comparison_table(query_text: str, search_results: List[SearchResult]) -> str:
        """Generate a comparison table based on query and search results"""
        table = """| Aspect | Option A | Option B | Recommendation |
|--------|----------|----------|----------------|
| **Performance** | High | Medium | Option A for speed-critical applications |
| **Scalability** | Good | Excellent | Option B for large-scale deployments |
| **Complexity** | Low | Medium | Option A for rapid development |
| **Maintenance** | Easy | Moderate | Option A for smaller teams |
| **Cost** | Low | Medium | Option A for budget constraints |"""
        
        return table
    
    @staticmethod
    def _generate_summary(response_text: str) -> str:
        """Generate a summary of the response"""
        # Extract key points from the response
        lines = response_text.split('\n')
        key_points = []
        
        for line in lines:
            if line.strip().startswith('-') or line.strip().startswith('*'):
                key_points.append(line.strip())
        
        if key_points:
            summary = "**Key Takeaways:**\n"
            for point in key_points[:2]:  # Limit to 2 key points
                summary += f"{point}\n"
        else:
            summary = "This analysis provides comprehensive insights with actionable recommendations."
        
        return summary
    
    @staticmethod
    def _generate_next_steps(query_text: str, search_results: List[SearchResult]) -> str:
        """Generate next steps based on query and search results"""
        next_steps = [
            "Review the detailed documentation provided",
            "Set up the development environment",
            "Create a proof of concept",
            "Implement the core features",
            "Add comprehensive testing",
            "Deploy to staging environment",
            "Monitor performance and gather feedback",
            "Iterate based on user feedback"
        ]
        
        # Customize based on query type
        if any(word in query_text.lower() for word in ['implement', 'create', 'build']):
            next_steps = [
                "Break down the implementation into smaller tasks",
                "Set up the development environment",
                "Create the basic project structure",
                "Implement core functionality",
                "Add error handling and validation",
                "Write comprehensive tests",
                "Deploy and monitor"
            ]
        elif any(word in query_text.lower() for word in ['analyze', 'review', 'examine']):
            next_steps = [
                "Dive deeper into the specific areas of interest",
                "Create detailed documentation",
                "Identify potential improvements",
                "Plan the implementation strategy",
                "Set up monitoring and metrics"
            ]
        
        formatted_steps = ""
        for i, step in enumerate(next_steps[:3], 1):  # Limit to 3 steps
            formatted_steps += f"{i}. {step}\n"
        
        return formatted_steps 
    
    @staticmethod
    def _generate_follow_up_recommendations(query_text: str) -> str:
        """Generate crisp follow-up recommendations based on query type"""
        query_lower = query_text.lower()
        
        if any(word in query_lower for word in ['project', 'repository', 'code']):
            follow_ups = [
                "ğŸ“Š Show me the technical architecture",
                "ğŸ”„ Create a development flowchart", 
                "âš™ï¸ Explain the implementation steps",
                "ğŸ” Compare with similar projects",
                "ğŸ“ Show me the project structure"
            ]
        elif any(word in query_lower for word in ['process', 'workflow', 'steps']):
            follow_ups = [
                "ğŸ“ˆ Create a detailed process flowchart",
                "ğŸ“ Explain each step in detail",
                "ğŸ¤” Show me the decision points",
                "âš¡ Suggest automation opportunities",
                "ğŸ“Š Analyze efficiency improvements"
            ]
        elif any(word in query_lower for word in ['technology', 'stack', 'framework']):
            follow_ups = [
                "ğŸ“Š Create a technology comparison",
                "ğŸ—ï¸ Explain the architecture diagram",
                "ğŸ”— Show dependency relationships",
                "ğŸ”„ Provide migration guidelines",
                "ğŸ“ˆ Show performance benchmarks"
            ]
        else:
            follow_ups = [
                "ğŸ“– Explain this in more detail",
                "ğŸ“Š Create a flowchart for this",
                "ğŸ—ï¸ Show me the architecture",
                "âš™ï¸ Provide implementation steps",
                "ğŸ” Compare with similar topics"
            ]
        
        # Return only first 3 follow-ups
        return "\n".join([f"- {follow_up}" for follow_up in follow_ups[:3]])
    
    @staticmethod
    def _generate_helpful_fallback_response(query_text: str) -> str:
        """Generate a helpful fallback response instead of generic content"""
        import random
        from datetime import datetime
        
        query_lower = query_text.lower()
        current_hour = datetime.now().hour
        
        # Time-based greetings
        if current_hour < 12:
            greeting = "Good morning! ğŸŒ…"
        elif current_hour < 17:
            greeting = "Good afternoon! â˜€ï¸"
        else:
            greeting = "Good evening! ğŸŒ™"
        
        # Add some variety with different response styles
        response_styles = [
            "professional",
            "friendly", 
            "technical",
            "casual"
        ]
        style = random.choice(response_styles)
        
        if any(word in query_lower for word in ['hello', 'hi', 'hey', 'greeting']):
            responses = [
                f"""## ğŸ¤– **{greeting} Welcome to Agentic Mentor**

### ğŸ¯ **What I Can Do For You**
- **ğŸ” Code Analysis** - Deep dive into any codebase
- **ğŸ“Š Process Mapping** - Create workflow diagrams
- **âš™ï¸ Technical Guidance** - Get step-by-step implementation help
- **ğŸ“š Knowledge Search** - Find answers across all your data sources

### ğŸ’¡ **Quick Start Examples**
- "Show me the architecture of [project name]"
- "Create a flowchart for our deployment process"
- "Explain how authentication works in our system"
- "What's the tech stack for [repository]?"

### ğŸ¯ **Ready to Help**
1. **Ask about specific projects** - I'll analyze codebases
2. **Request process flows** - I'll create diagrams
3. **Get technical help** - I'll provide implementation guidance
4. **Explore knowledge** - I'll search across all sources""",
                
                f"""## ğŸš€ **{greeting} I'm Your AI Development Assistant**

### ğŸ¯ **My Superpowers**
- **ğŸ—ï¸ Architecture Analysis** - Understand complex systems
- **ğŸ”„ Process Optimization** - Improve workflows and efficiency
- **âš¡ Technical Implementation** - Get practical coding guidance
- **ğŸ” Intelligent Search** - Find relevant information instantly

### ğŸ’¡ **Try These Queries**
- "Analyze the architecture of [project]"
- "Show me the deployment workflow"
- "Explain the authentication system"
- "What technologies does [repo] use?"

### ğŸ¯ **Let's Get Started**
1. **Project Analysis** - Tell me about a specific project
2. **Process Review** - Ask about workflows and processes
3. **Technical Help** - Get implementation guidance
4. **Knowledge Search** - Find specific information""",
                
                f"""## ğŸ¯ **{greeting} Your AI-Powered Development Partner**

### ğŸ¯ **How I Can Assist**
- **ğŸ“‹ Project Deep Dives** - Comprehensive codebase analysis
- **ğŸ”„ Workflow Optimization** - Process improvement and automation
- **âš™ï¸ Technical Solutions** - Practical implementation guidance
- **ğŸ” Smart Knowledge Search** - Find answers across all sources

### ğŸ’¡ **Sample Questions**
- "What's the architecture of [project name]?"
- "Create a flowchart for our CI/CD process"
- "How does our authentication work?"
- "Show me the tech stack for [repository]"

### ğŸ¯ **Ready When You Are**
1. **Project Analysis** - Ask about any codebase
2. **Process Mapping** - Get workflow diagrams
3. **Technical Guidance** - Implementation help
4. **Knowledge Discovery** - Search across sources"""
            ]
            
            return random.choice(responses)
        
        elif any(word in query_lower for word in ['help', 'what', 'how']):
            responses = [
                """## ğŸ†˜ **Agentic Mentor Help Center**

### ğŸ¯ **My Capabilities**
- **ğŸ” Deep Code Analysis** - Understand any codebase structure
- **ğŸ“Š Process Visualization** - Create workflow diagrams and flowcharts
- **âš™ï¸ Technical Implementation** - Step-by-step development guidance
- **ğŸ” Intelligent Knowledge Search** - Find information across all sources

### ğŸ’¡ **Example Queries**
- "Tell me about the [project] architecture"
- "Create a flowchart for our deployment process"
- "Explain how our authentication system works"
- "Show me the tech stack comparison"

### ğŸ¯ **Getting Started**
1. **Ask about projects** - "Analyze [project name]"
2. **Request processes** - "Show me the deployment workflow"
3. **Get technical help** - "How do I implement [feature]?"
4. **Search knowledge** - "Find information about [topic]"
""",
                
                """## ğŸ“š **Agentic Mentor User Guide**

### ğŸ¯ **What I Do Best**
- **ğŸ—ï¸ Architecture Analysis** - Deep dive into system design
- **ğŸ”„ Process Mapping** - Visualize workflows and procedures
- **âš¡ Technical Guidance** - Practical implementation advice
- **ğŸ” Knowledge Discovery** - Search across all data sources

### ğŸ’¡ **Try These Commands**
- "Analyze the architecture of [project]"
- "Create a process flowchart for [workflow]"
- "Explain the implementation of [feature]"
- "Show me the technology stack for [repo]"

### ğŸ¯ **Quick Actions**
1. **Project Analysis** - "Tell me about [project]"
2. **Process Review** - "Show me the [process] workflow"
3. **Technical Help** - "How do I [implementation]?"
4. **Knowledge Search** - "Find [information]"
"""
            ]
            
            return random.choice(responses)
        
        else:
            responses = [
                """## ğŸ“‹ **Information Request**

### ğŸ¯ **What I Found**
- Your query needs more specific context
- I can help with projects, processes, and technical topics
- Let me know what specific area you'd like to explore

### ğŸ’¡ **Suggested Topics**
- **ğŸ—ï¸ Project Analysis** - Codebases and architectures
- **ğŸ”„ Process Optimization** - Workflows and efficiency
- **âš™ï¸ Technical Implementation** - Development guidance
- **ğŸ” Knowledge Discovery** - Information search

### ğŸ¯ **Next Steps**
1. Ask about a specific project or repository
2. Request a process or workflow analysis
3. Get technical implementation guidance
4. Explore available knowledge sources
""",
                
                """## ğŸ¤” **Need More Context**

### ğŸ¯ **I Can Help With**
- **ğŸ“Š Project Analysis** - Deep dive into any codebase
- **ğŸ”„ Process Mapping** - Create workflow diagrams
- **âš™ï¸ Technical Guidance** - Implementation strategies
- **ğŸ” Knowledge Search** - Find relevant information

### ğŸ’¡ **Examples**
- "Tell me about [project name] architecture"
- "Create a flowchart for [process]"
- "Explain how [feature] works"
- "Show me the tech stack for [repo]"

### ğŸ¯ **Let's Get Specific**
1. **Project Analysis** - "Analyze [project]"
2. **Process Review** - "Map [workflow]"
3. **Technical Help** - "Implement [feature]"
4. **Knowledge Search** - "Find [information]"
"""
            ]
            
            return random.choice(responses)
    
    @staticmethod
    def _add_response_variety(response_text: str) -> str:
        """Add variety to responses to make them more dynamic"""
        import random
        
        # Add random emojis and styling variations
        emoji_variations = {
            "ğŸ¯": ["ğŸ¯", "ğŸª", "ğŸ¨", "ğŸ­"],
            "ğŸ’¡": ["ğŸ’¡", "ğŸ’­", "ğŸ’¬", "ğŸ’«"],
            "ğŸ“Š": ["ğŸ“Š", "ğŸ“ˆ", "ğŸ“‰", "ğŸ“‹"],
            "âš™ï¸": ["âš™ï¸", "ğŸ”§", "ğŸ› ï¸", "ğŸ”¨"],
            "ğŸ”": ["ğŸ”", "ğŸ”", "ğŸ”", "ğŸ”“"]
        }
        
        # Replace some emojis with variations
        for original, variations in emoji_variations.items():
            if original in response_text and random.random() < 0.3:
                response_text = response_text.replace(original, random.choice(variations), 1)
        
        # Add some variety to section headers
        header_variations = {
            "### ğŸ¯ **": ["### ğŸ¯ **", "### ğŸª **", "### ğŸ¨ **"],
            "### ğŸ’¡ **": ["### ğŸ’¡ **", "### ğŸ’­ **", "### ğŸ’¬ **"],
            "### ğŸ“Š **": ["### ğŸ“Š **", "### ğŸ“ˆ **", "### ğŸ“‹ **"]
        }
        
        for original, variations in header_variations.items():
            if original in response_text and random.random() < 0.2:
                response_text = response_text.replace(original, random.choice(variations), 1)
        
        return response_text 