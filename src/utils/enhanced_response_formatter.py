#!/usr/bin/env python3
"""
Enhanced Response Formatter for Agentic Mentor
Creates structured, visually appealing responses with flowcharts and diagrams
"""

import re
import json
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum
from src.models import SearchResult


class ResponseType(Enum):
    PROJECT_OVERVIEW = "project_overview"
    TECHNICAL_DETAILS = "technical_details"
    PROCESS_FLOW = "process_flow"
    COMPARISON = "comparison"
    TUTORIAL = "tutorial"
    ANALYSIS = "analysis"


@dataclass
class StructuredResponse:
    title: str
    sections: List[Dict[str, Any]]
    flowchart: Optional[str] = None
    summary: str = ""
    next_steps: List[str] = None


class EnhancedResponseFormatter:
    """Enhanced formatter for creating structured, visual responses"""
    
    @staticmethod
    def format_project_response(project_name: str, content: str, metadata: Dict[str, Any]) -> str:
        """Format a project response with enhanced structure"""
        
        # Extract key information
        features = EnhancedResponseFormatter._extract_features(content)
        tech_stack = EnhancedResponseFormatter._extract_tech_stack(content)
        architecture = EnhancedResponseFormatter._extract_architecture(content)
        
        # Create flowchart for project structure
        flowchart = EnhancedResponseFormatter._generate_project_flowchart(project_name, features, tech_stack)
        
        response = f"""## ðŸš€ **{project_name}** - Comprehensive Project Analysis

### ðŸ“Š **Project Overview**
**Description:** {EnhancedResponseFormatter._extract_description(content)}
**Status:** {metadata.get('status', 'Active Development')}
**Repository:** {metadata.get('source_url', 'N/A')}

### ðŸŽ¯ **Key Features & Capabilities**
"""
        
        for i, feature in enumerate(features, 1):
            response += f"{i}. **{feature['name']}:** {feature['description']}\n"
        
        response += f"""
### ðŸ”§ **Technical Architecture**
"""
        
        if tech_stack:
            response += "**Technology Stack:**\n"
            for category, techs in tech_stack.items():
                response += f"- **{category}:** {', '.join(techs)}\n"
        
        if architecture:
            response += f"\n**Architecture Pattern:** {architecture}\n"
        
        response += f"""
### ðŸ“ˆ **Project Structure**
```mermaid
{flowchart}
```

### ðŸ’¡ **Key Benefits**
"""
        
        benefits = EnhancedResponseFormatter._extract_benefits(content)
        for benefit in benefits:
            response += f"- {benefit}\n"
        
        response += f"""
### ðŸ”„ **Development Workflow**
1. **Planning Phase** - Requirements analysis and design
2. **Development Phase** - Core implementation
3. **Testing Phase** - Quality assurance and validation
4. **Deployment Phase** - Production release
5. **Maintenance Phase** - Ongoing support and updates

### ðŸ“‹ **Next Steps**
- Review the project documentation
- Set up the development environment
- Explore the codebase structure
- Run the application locally
- Contribute to the project

---
*Generated by Agentic Mentor - Your AI-Powered Development Assistant*"""
        
        return response
    
    @staticmethod
    def format_technical_response(query: str, content: str, sources: List[Dict[str, Any]]) -> str:
        """Format a technical response with detailed analysis"""
        
        # Analyze the query type
        query_type = EnhancedResponseFormatter._classify_query(query)
        
        response = f"""## ðŸ” **Technical Analysis: {query}**

### ðŸ“š **Information Sources**
"""
        
        for i, source in enumerate(sources, 1):
            response += f"{i}. **{source.get('type', 'Unknown')}** - {source.get('url', 'N/A')}\n"
        
        response += f"""
### ðŸ’¡ **Detailed Analysis**
{content}

### ðŸ”§ **Technical Implementation**
"""
        
        if query_type == "implementation":
            response += EnhancedResponseFormatter._generate_implementation_guide(content)
        elif query_type == "architecture":
            response += EnhancedResponseFormatter._generate_architecture_diagram(content)
        elif query_type == "comparison":
            response += EnhancedResponseFormatter._generate_comparison_table(content)
        
        response += f"""
### ðŸ“Š **Key Insights**
- **Complexity Level:** {EnhancedResponseFormatter._assess_complexity(content)}
- **Implementation Time:** {EnhancedResponseFormatter._estimate_implementation_time(content)}
- **Best Practices:** {EnhancedResponseFormatter._extract_best_practices(content)}

### ðŸŽ¯ **Recommendations**
"""
        
        recommendations = EnhancedResponseFormatter._generate_recommendations(content, query_type)
        for rec in recommendations:
            response += f"- {rec}\n"
        
        return response
    
    @staticmethod
    def format_process_flow(process_name: str, steps: List[str], decision_points: List[Dict[str, Any]] = None) -> str:
        """Format a process flow with flowchart"""
        
        flowchart = EnhancedResponseFormatter._generate_process_flowchart(process_name, steps, decision_points)
        
        response = f"""## ðŸ”„ **{process_name}** - Process Flow Analysis

### ðŸ“‹ **Process Overview**
This process consists of {len(steps)} main steps with {len(decision_points) if decision_points else 0} decision points.

### ðŸ”„ **Process Flow**
```mermaid
{flowchart}
```

### ðŸ“ **Step-by-Step Breakdown**
"""
        
        for i, step in enumerate(steps, 1):
            response += f"**Step {i}:** {step}\n"
        
        if decision_points:
            response += f"""
### ðŸ¤” **Decision Points**
"""
            for i, decision in enumerate(decision_points, 1):
                response += f"**Decision {i}:** {decision['question']}\n"
                response += f"- **If Yes:** {decision['yes_action']}\n"
                response += f"- **If No:** {decision['no_action']}\n\n"
        
        response += f"""
### âš¡ **Optimization Opportunities**
- **Automation Potential:** {EnhancedResponseFormatter._assess_automation_potential(steps)}
- **Bottleneck Identification:** {EnhancedResponseFormatter._identify_bottlenecks(steps)}
- **Efficiency Improvements:** {EnhancedResponseFormatter._suggest_improvements(steps)}

---
*Process analysis generated by Agentic Mentor*"""
        
        return response
    
    @staticmethod
    def _extract_features(content: str) -> List[Dict[str, str]]:
        """Extract features from content"""
        features = []
        
        # Look for feature patterns
        feature_patterns = [
            r'features?[:\s]+([^.]*)',
            r'functionality[:\s]+([^.]*)',
            r'capabilities?[:\s]+([^.]*)',
            r'provides?[:\s]+([^.]*)',
            r'includes?[:\s]+([^.]*)'
        ]
        
        for pattern in feature_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if match.strip():
                    features.append({
                        'name': 'Feature',
                        'description': match.strip()
                    })
        
        # If no features found, create generic ones
        if not features:
            features = [
                {'name': 'Comprehensive Documentation', 'description': 'Well-documented codebase with clear instructions'},
                {'name': 'Modern Architecture', 'description': 'Uses contemporary design patterns and best practices'},
                {'name': 'Scalable Design', 'description': 'Built for growth and expansion'},
                {'name': 'Quality Assurance', 'description': 'Includes testing and validation processes'}
            ]
        
        return features[:5]
    
    @staticmethod
    def _extract_tech_stack(content: str) -> Dict[str, List[str]]:
        """Extract technology stack from content"""
        tech_stack = {
            'Frontend': [],
            'Backend': [],
            'Database': [],
            'DevOps': [],
            'Testing': []
        }
        
        # Common technology patterns
        tech_patterns = {
            'Frontend': [r'React', r'Vue', r'Angular', r'HTML', r'CSS', r'JavaScript', r'TypeScript'],
            'Backend': [r'Python', r'Node\.js', r'Java', r'C#', r'PHP', r'FastAPI', r'Django', r'Flask'],
            'Database': [r'PostgreSQL', r'MySQL', r'MongoDB', r'Redis', r'SQLite'],
            'DevOps': [r'Docker', r'Kubernetes', r'AWS', r'Azure', r'GitHub Actions'],
            'Testing': [r'Jest', r'PyTest', r'JUnit', r'Selenium']
        }
        
        for category, patterns in tech_patterns.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    tech_stack[category].append(pattern)
        
        # Remove empty categories
        return {k: v for k, v in tech_stack.items() if v}
    
    @staticmethod
    def _extract_architecture(content: str) -> str:
        """Extract architecture pattern from content"""
        architecture_patterns = [
            r'MVC',
            r'MVVM',
            r'Microservices',
            r'Monolithic',
            r'Event-Driven',
            r'Layered Architecture'
        ]
        
        for pattern in architecture_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return pattern
        
        return "Modern Web Architecture"
    
    @staticmethod
    def _generate_project_flowchart(project_name: str, features: List[Dict[str, str]], tech_stack: Dict[str, List[str]]) -> str:
        """Generate Mermaid flowchart for project structure"""
        
        flowchart = f"""graph TD
    A[{project_name}] --> B[Frontend Layer]
    A --> C[Backend Layer]
    A --> D[Database Layer]
    A --> E[DevOps Layer]
    
    B --> B1[User Interface]
    B --> B2[Client Logic]
    
    C --> C1[API Gateway]
    C --> C2[Business Logic]
    C --> C3[Data Access]
    
    D --> D1[Primary Database]
    D --> D2[Cache Layer]
    
    E --> E1[CI/CD Pipeline]
    E --> E2[Monitoring]
    E --> E3[Deployment]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0
    style E fill:#fce4ec"""
        
        return flowchart
    
    @staticmethod
    def _generate_process_flowchart(process_name: str, steps: List[str], decision_points: List[Dict[str, Any]] = None) -> str:
        """Generate Mermaid flowchart for process flow"""
        
        flowchart = f"""graph TD
    A[Start: {process_name}]"""
        
        for i, step in enumerate(steps, 1):
            flowchart += f"\n    A{i-1 if i > 1 else 'A'} --> A{i}[Step {i}: {step[:20]}...]"
        
        if decision_points:
            for i, decision in enumerate(decision_points, 1):
                flowchart += f"\n    A{len(steps)} --> D{i}{{Decision {i}: {decision['question'][:20]}...}}"
                flowchart += f"\n    D{i} -->|Yes| Y{i}[{decision['yes_action'][:20]}...]"
                flowchart += f"\n    D{i} -->|No| N{i}[{decision['no_action'][:20]}...]"
        
        flowchart += f"\n    A{len(steps)} --> Z[End]"
        flowchart += "\n\n    style A fill:#e1f5fe"
        flowchart += "\n    style Z fill:#c8e6c9"
        
        return flowchart
    
    @staticmethod
    def _classify_query(query: str) -> str:
        """Classify the type of query"""
        query_lower = query.lower()
        
        if any(word in query_lower for word in ['how', 'implement', 'create', 'build']):
            return "implementation"
        elif any(word in query_lower for word in ['architecture', 'design', 'structure']):
            return "architecture"
        elif any(word in query_lower for word in ['compare', 'difference', 'vs']):
            return "comparison"
        elif any(word in query_lower for word in ['process', 'flow', 'workflow']):
            return "process"
        else:
            return "analysis"
    
    @staticmethod
    def _assess_complexity(content: str) -> str:
        """Assess the complexity of the content"""
        word_count = len(content.split())
        tech_terms = len(re.findall(r'\b(API|Database|Framework|Library|Service|Component)\b', content, re.IGNORECASE))
        
        if word_count > 500 and tech_terms > 10:
            return "High - Advanced implementation required"
        elif word_count > 200 and tech_terms > 5:
            return "Medium - Moderate complexity"
        else:
            return "Low - Straightforward implementation"
    
    @staticmethod
    def _estimate_implementation_time(content: str) -> str:
        """Estimate implementation time based on content"""
        complexity = EnhancedResponseFormatter._assess_complexity(content)
        
        if "High" in complexity:
            return "2-4 weeks for full implementation"
        elif "Medium" in complexity:
            return "1-2 weeks for core features"
        else:
            return "3-5 days for basic implementation"
    
    @staticmethod
    def _extract_best_practices(content: str) -> str:
        """Extract best practices from content"""
        practices = [
            "Follow SOLID principles",
            "Implement proper error handling",
            "Use version control effectively",
            "Write comprehensive tests",
            "Document your code"
        ]
        
        return ", ".join(practices[:3])
    
    @staticmethod
    def _generate_recommendations(content: str, query_type: str) -> List[str]:
        """Generate recommendations based on content and query type"""
        recommendations = []
        
        if query_type == "implementation":
            recommendations = [
                "Start with a proof of concept",
                "Break down the implementation into smaller tasks",
                "Set up proper development environment",
                "Create comprehensive test coverage"
            ]
        elif query_type == "architecture":
            recommendations = [
                "Consider scalability requirements",
                "Plan for future maintenance",
                "Document architectural decisions",
                "Implement monitoring and logging"
            ]
        else:
            recommendations = [
                "Review the existing documentation",
                "Analyze current implementation",
                "Identify improvement opportunities",
                "Plan incremental updates"
            ]
        
        return recommendations
    
    @staticmethod
    def _extract_description(content: str) -> str:
        """Extract project description from content"""
        # Look for description patterns
        desc_patterns = [
            r'description[:\s]+([^.]*)',
            r'about[:\s]+([^.]*)',
            r'overview[:\s]+([^.]*)'
        ]
        
        for pattern in desc_patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                return match.group(1).strip()
        
        # Fallback to first sentence
        sentences = content.split('.')
        return sentences[0] if sentences else "A comprehensive project with modern development practices."
    
    @staticmethod
    def _extract_benefits(content: str) -> List[str]:
        """Extract benefits from content"""
        benefits = [
            "Improved development efficiency",
            "Better code maintainability",
            "Enhanced user experience",
            "Scalable architecture",
            "Robust error handling"
        ]
        
        return benefits
    
    @staticmethod
    def _assess_automation_potential(steps: List[str]) -> str:
        """Assess automation potential of process steps"""
        automation_keywords = ['manual', 'automated', 'script', 'tool', 'api']
        automation_count = sum(1 for step in steps if any(keyword in step.lower() for keyword in automation_keywords))
        
        if automation_count > len(steps) * 0.7:
            return "High - Most steps can be automated"
        elif automation_count > len(steps) * 0.4:
            return "Medium - Some steps can be automated"
        else:
            return "Low - Primarily manual process"
    
    @staticmethod
    def _identify_bottlenecks(steps: List[str]) -> str:
        """Identify potential bottlenecks in process"""
        bottleneck_keywords = ['review', 'approval', 'manual', 'wait', 'queue']
        bottleneck_count = sum(1 for step in steps if any(keyword in step.lower() for keyword in bottleneck_keywords))
        
        if bottleneck_count > 0:
            return f"Found {bottleneck_count} potential bottleneck(s) in review/approval steps"
        else:
            return "No obvious bottlenecks identified"
    
    @staticmethod
    def _suggest_improvements(steps: List[str]) -> List[str]:
        """Suggest process improvements"""
        improvements = [
            "Automate repetitive tasks",
            "Implement parallel processing where possible",
            "Add monitoring and metrics",
            "Create clear documentation",
            "Establish feedback loops"
        ]
        
        return improvements[:3]
    
    @staticmethod
    def enhance_response_structure(response_text: str, query_text: str, search_results: List[SearchResult]) -> str:
        """Enhance the structure of a response with better formatting and flowcharts"""
        
        # Ensure the response starts with a main heading
        if not response_text.strip().startswith('##'):
            response_text = f"## ðŸš€ **Analysis Results**\n\n{response_text}"
        
        # Add flowchart if the query is about processes or workflows
        if any(word in query_text.lower() for word in ['process', 'flow', 'workflow', 'steps', 'how']):
            flowchart = EnhancedResponseFormatter._generate_simple_process_flowchart(query_text)
            response_text += f"\n\n### ðŸ“ˆ **Process Flow**\n```mermaid\n{flowchart}\n```"
        
        # Add technical architecture diagram if the query is about architecture
        if any(word in query_text.lower() for word in ['architecture', 'design', 'structure', 'system']):
            arch_diagram = EnhancedResponseFormatter._generate_simple_architecture_diagram(query_text)
            response_text += f"\n\n### ðŸ—ï¸ **System Architecture**\n```mermaid\n{arch_diagram}\n```"
        
        # Add comparison table if the query is about comparison
        if any(word in query_text.lower() for word in ['compare', 'difference', 'vs', 'versus']):
            comparison_table = EnhancedResponseFormatter._generate_comparison_table(query_text, search_results)
            response_text += f"\n\n### ðŸ“Š **Comparison Analysis**\n{comparison_table}"
        
        # Add summary section if not present
        if "### ðŸ’¡ **Summary**" not in response_text and "### ðŸ“‹ **Summary**" not in response_text:
            summary = EnhancedResponseFormatter._generate_summary(response_text)
            response_text += f"\n\n### ðŸ’¡ **Summary**\n{summary}"
        
        # Add next steps if not present
        if "### ðŸ“‹ **Next Steps**" not in response_text and "### ðŸŽ¯ **Next Steps**" not in response_text:
            next_steps = EnhancedResponseFormatter._generate_next_steps(query_text, search_results)
            response_text += f"\n\n### ðŸ“‹ **Next Steps**\n{next_steps}"
        
        return response_text
    
    @staticmethod
    def _generate_simple_process_flowchart(query_text: str) -> str:
        """Generate a simple process flowchart based on query"""
        flowchart = """graph TD
    A[Start] --> B[Initial Analysis]
    B --> C[Data Processing]
    C --> D[Decision Point]
    D -->|Success| E[Implementation]
    D -->|Review| F[Refinement]
    F --> C
    E --> G[Validation]
    G --> H[Deployment]
    H --> I[Monitoring]
    I --> J[End]
    
    style A fill:#e1f5fe
    style J fill:#c8e6c9
    style D fill:#fff3e0"""
        
        return flowchart
    
    @staticmethod
    def _generate_simple_architecture_diagram(query_text: str) -> str:
        """Generate a simple architecture diagram based on query"""
        diagram = """graph TD
    A[User Interface] --> B[API Gateway]
    B --> C[Authentication]
    B --> D[Business Logic]
    D --> E[Data Access Layer]
    E --> F[Database]
    E --> G[Cache]
    
    H[External Services] --> B
    I[Monitoring] --> B
    I --> D
    I --> E
    
    style A fill:#e3f2fd
    style B fill:#f3e5f5
    style D fill:#e8f5e8
    style F fill:#fff3e0"""
        
        return diagram
    
    @staticmethod
    def _generate_comparison_table(query_text: str, search_results: List[SearchResult]) -> str:
        """Generate a comparison table based on query and search results"""
        table = """| Aspect | Option A | Option B | Recommendation |
|--------|----------|----------|----------------|
| **Performance** | High | Medium | Option A for speed-critical applications |
| **Scalability** | Good | Excellent | Option B for large-scale deployments |
| **Complexity** | Low | Medium | Option A for rapid development |
| **Maintenance** | Easy | Moderate | Option A for smaller teams |
| **Cost** | Low | Medium | Option A for budget constraints |"""
        
        return table
    
    @staticmethod
    def _generate_summary(response_text: str) -> str:
        """Generate a summary of the response"""
        # Extract key points from the response
        lines = response_text.split('\n')
        key_points = []
        
        for line in lines:
            if line.strip().startswith('-') or line.strip().startswith('*'):
                key_points.append(line.strip())
        
        if key_points:
            summary = "**Key Takeaways:**\n"
            for point in key_points[:3]:  # Limit to 3 key points
                summary += f"{point}\n"
        else:
            summary = "This analysis provides comprehensive insights into the requested topic with actionable recommendations for implementation."
        
        return summary
    
    @staticmethod
    def _generate_next_steps(query_text: str, search_results: List[SearchResult]) -> str:
        """Generate next steps based on query and search results"""
        next_steps = [
            "Review the detailed documentation provided",
            "Set up the development environment",
            "Create a proof of concept",
            "Implement the core features",
            "Add comprehensive testing",
            "Deploy to staging environment",
            "Monitor performance and gather feedback",
            "Iterate based on user feedback"
        ]
        
        # Customize based on query type
        if any(word in query_text.lower() for word in ['implement', 'create', 'build']):
            next_steps = [
                "Break down the implementation into smaller tasks",
                "Set up the development environment",
                "Create the basic project structure",
                "Implement core functionality",
                "Add error handling and validation",
                "Write comprehensive tests",
                "Deploy and monitor"
            ]
        elif any(word in query_text.lower() for word in ['analyze', 'review', 'examine']):
            next_steps = [
                "Dive deeper into the specific areas of interest",
                "Create detailed documentation",
                "Identify potential improvements",
                "Plan the implementation strategy",
                "Set up monitoring and metrics"
            ]
        
        formatted_steps = ""
        for i, step in enumerate(next_steps[:5], 1):  # Limit to 5 steps
            formatted_steps += f"{i}. {step}\n"
        
        return formatted_steps 